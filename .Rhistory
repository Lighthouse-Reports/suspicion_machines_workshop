occupation_home_country_master_df <- data.frame()
for(country in countries_to_analyze){
fp_college <- paste0(fp_1, country, fp_2)
cur_df_college <- arrow::read_feather(fp_college)
fp_all <- paste0(fp_1, country, '_ALL', fp_2)
cur_df_all <- arrow::read_feather(fp_all)
college_educated_df <- cur_df_all %>%
group_by(COUNTRY, REFYEAR, is_immigrant) %>%
summarise(mean_college_educated = mean(is_college_educated, na.rm = T))
college_educated_master_df <- college_educated_master_df %>%
bind_rows(college_educated_df)
gs_education_bw_df <- cur_df_college %>%
filter(REFYEAR > 2016, !is.na(hatfield1d)) %>%
group_by(COUNTRY, is_global_south, hatfield1d) %>%
summarise(uemp_mean = mean(uemp, na.rm = T),
overed_mean = mean(overed_1sd_hat_isced, na.rm = T),
unemployed_mean = mean(is_unemployed, na.rm = T),
temp_mean = mean(is_temp, na.rm = T),
n = n()) %>%
pivot_wider(names_from = is_global_south, values_from = c('uemp_mean', 'overed_mean', 'unemployed_mean', 'temp_mean', 'n'))
gs_education_bw_master_df <- gs_education_bw_master_df %>%
bind_rows(gs_education_bw_df)
# occupation_home_country_df <- cur_df %>%
#   filter(previous_job_abroad == 1) %>%
#   group_by(COUNTRY, ISCO08_3DPR) %>%
#   summarise(uemp_mean = mean(uemp, na.rm = T),
#             overed_mean = mean(overed_1sd_hat_isced, na.rm = T),
#             unemployed_mean = mean(is_unemployed, na.rm = T),
#             count = n()) %>%
#   filter(!is.na(ISCO08_3DPR))
# occupation_home_country_master_df <- occupation_home_country_master_df %>%
#   bind_rows(occupation_home_country_df)
}
View(gs_education_bw_master_df)
output_fp <- paste0(cur_date, 'Results/scratchpad/240305_maud_questions/')
dir.create(output_fp, showWarnings = F)
college_educated_master_df <- college_educated_master_df %>%
filter(!is.na(is_immigrant))
write.csv(college_educated_master_df, paste(output_fp, 'skilled_occupation_country_year.csv'))
ggplot(college_educated_master_df, aes(x = REFYEAR, y = mean_college_educated, color = as.factor(is_immigrant)))+
geom_point()+
facet_wrap(.~COUNTRY)+
labs(x = 'Year', y = '% college educated',
color = 'Is immigrant', title = 'Share college educated by year, country, and migration status')+
scale_y_continuous(labels = scales::percent)
ggsave(paste(output_fp, 'skilled_occupation_country_year.png'), width = 10, height = 15)
gs_education_bw_master_df <- gs_education_bw_master_df %>%
filter(!is.na(hatfield1d)) %>%
dplyr::mutate(hatfield_text = case_when(hatfield1d == 0 ~ 'basic',
hatfield1d == 1 ~ 'education',
hatfield1d == 2 ~ 'arts/humanities',
hatfield1d == 3 ~ 'social sciences',
hatfield1d == 4 ~ 'business/law',
hatfield1d == 5 ~ 'natural sciences',
hatfield1d == 6 ~ 'ict',
hatfield1d == 7 ~ 'engineering',
hatfield1d == 8 ~ 'agriculture',
hatfield1d == 9 ~ 'health',
hatfield1d == 10 ~ 'services',
.default = 'Unknown Field')) %>%
dplyr::select(-ends_with('NA'))
write.csv(gs_education_bw_master_df, paste(output_fp, 'gs_education_brainwaste_metrics_country.csv'))
cur_df$previous_job_abroad
table(cur_df$previous_job_abroad)
table(cur_df$previous_job_abroad, cur_df$REFYEAR)
occupation_home_country_df <- cur_df %>%
filter(previous_job_abroad == 1, is_immigrant == 1, REFYEAR > 2016) #%>%
View(occupation_home_country_master_df)
View(occupation_home_country_df)
occupation_home_country_df <- cur_df %>%
filter(previous_job_abroad == 1, is_immigrant == 1, REFYEAR > 2016) %>%
group_by(COUNTRY, ISCO08_3DPR) %>%
summarise(uemp_mean = mean(uemp, na.rm = T),
overed_mean = mean(overed_1sd_hat_isced, na.rm = T),
unemployed_mean = mean(is_unemployed, na.rm = T),
count = n()) #%>%
View(occupation_home_country_df)
occupation_home_country_df <- cur_df_college %>%
filter(previous_job_abroad == 1, is_immigrant == 1, REFYEAR > 2016) %>%
group_by(COUNTRY, ISCO08_3DPR) %>%
summarise(uemp_mean = mean(uemp, na.rm = T),
overed_mean = mean(overed_1sd_hat_isced, na.rm = T),
unemployed_mean = mean(is_unemployed, na.rm = T),
count = n()) #%>%
View(occupation_home_country_df)
college_educated_master_df <- data.frame()
gs_education_bw_master_df <- data.frame()
occupation_home_country_master_df <- data.frame()
for(country in 'FR'){
fp_college <- paste0(fp_1, country, fp_2)
cur_df_college <- arrow::read_feather(fp_college)
fp_all <- paste0(fp_1, country, '_ALL', fp_2)
cur_df_all <- arrow::read_feather(fp_all)
college_educated_df <- cur_df_all %>%
group_by(COUNTRY, REFYEAR, is_immigrant) %>%
summarise(mean_college_educated = mean(is_college_educated, na.rm = T))
college_educated_master_df <- college_educated_master_df %>%
bind_rows(college_educated_df)
gs_education_bw_df <- cur_df_college %>%
filter(REFYEAR > 2016, !is.na(hatfield1d)) %>%
group_by(COUNTRY, is_global_south, hatfield1d) %>%
summarise(uemp_mean = mean(uemp, na.rm = T),
overed_mean = mean(overed_1sd_hat_isced, na.rm = T),
unemployed_mean = mean(is_unemployed, na.rm = T),
temp_mean = mean(is_temp, na.rm = T),
n = n()) %>%
pivot_wider(names_from = is_global_south, values_from = c('uemp_mean', 'overed_mean', 'unemployed_mean', 'temp_mean', 'n'))
gs_education_bw_master_df <- gs_education_bw_master_df %>%
bind_rows(gs_education_bw_df)
occupation_home_country_df <- cur_df_college %>%
filter(previous_job_abroad == 1, is_immigrant == 1, REFYEAR > 2016) %>%
group_by(COUNTRY, ISCO08_3DPR) %>%
summarise(uemp_mean = mean(uemp, na.rm = T),
overed_mean = mean(overed_1sd_hat_isced, na.rm = T),
unemployed_mean = mean(is_unemployed, na.rm = T),
count = n()) #%>%
# filter(!is.na(ISCO08_3DPR))
occupation_home_country_master_df <- occupation_home_country_master_df %>%
bind_rows(occupation_home_country_df)
}
View(occupation_home_country_df)
my_df <- cur_df_college %>%
filter(previous_job_abroad == 1, is_immigrant == 1, REFYEAR > 2016) #%>%
my_df$COUNTRY
my_df$uemp
my_df$is_unemployed
my_df$overed_1sd_hat_isced
cur_df_college$overed_1sd_hat_isced
table(cur_df_college$overed_1sd_hat_isced)
table(cur_df_college$overed_1sd_hat_isced, useNA = 'always')
table(cur_df_college$overed_1sd_hat_isced, cur_df_college$REFYEAR, useNA = 'always')
table(cur_df_college$overed_1sd_hat_isced, cur_df_college$is_immigrant, useNA = 'always')
table(cur_df_college$overed_1sd_hat_isced, cur_df_college$previous_job_abroad, useNA = 'always')
table(cur_df_college$ISCO08_3D, cur_df_college$previous_job_abroad, useNA = 'always')
table(cur_df_college$ISCO08_3D, cur_df_college$last_job_abroad, useNA = 'always')
table(cur_df_all$ISCO08_3D, cur_df_all$last_job_abroad, useNA = 'always')
table(is.na(cur_df_college$ISCO08_3D), is.na(cur_df_college$ISCO88_3DPR), useNA = 'always')
table(is.na(cur_df_college$ISCO08_3D), is.na(cur_df_college$ISCO08_3DPR), useNA = 'always')
table(is.na(cur_df_college$ISCO08_3D), useNA = 'always')
table(is.na(cur_df_college$ISCO08_3DPR), useNA = 'always')
table(is.na(cur_df_college$ISCO08_3D), is.na(cur_df_college$ISCO08_3DPR), useNA = 'always')
table(cur_df_college$ISCO08_3D, cur_df_college$ISCO08_3DPR, useNA = 'always')
mydf <- table(cur_df_college$ISCO08_3D, cur_df_college$ISCO08_3DPR, useNA = 'always') %>% as.data.frame()
View(my_df)
View(mydf)
mydf <- table(cur_df_college$ISCO08_3D, cur_df_college$ISCO08_3DPR, useNA = 'always') %>% as.data.frame() %>% filter(!is.na(Var1), !is.na(Var2))
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '') #TODO change so it sets itself up to the dir it is in
setwd("/Users/justin-casimirbraun/GitHub/suspicion_machines_workshop")
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '/Users/justin-casimirbraun/GitHub/suspicion_machines_workshop') #TODO change so it sets itself up to the dir it is in
if (!require("pacman")) install.packages("pacman")
pacman::p_load(dplyr, ggplot2, caret, tidyr, readxl, corrplot, gbm)
if (!require("pacman")) install.packages("pacman")
pacman::p_load(dplyr, ggplot2, caret, tidyr, readxl, corrplot, gbm)
#This is synthetic data we build based on the real training data that was accidentally leaked to us.
# You can find our script to build this data here: https://github.com/Lighthouse-Reports/suspicion_machine
synth_df <- read.csv('data/01_raw/synth_data.csv')
#This is the same synthetic data as above but duplicated: in one copy, all people are set to be women, in the other, everybody is male
#You can also find the script we used to build the duplicates in our Github
synth_df_gender <- read.csv('data/01_raw/synth_data_gender.csv')
#This is the actual final model file from Rotterdam which we got through FOIA.
final_model <- readRDS('data/01_raw/20220929_finale_model.rds')$model[[1]]
#This is some basic demographic about the Rotterdam welfare beneficiary population we obtained through a press request.
demographics <- readxl::read_excel('data/01_raw/welfare_recepient_stats.xlsx', sheet = 'demographics')
print(demographics)
#format demographic data so it can be compared easily with the training data
demographics_formatted <- demographics %>%
dplyr::select(characteristic_english, group_english, count) %>%
dplyr::group_by(characteristic_english) %>%
dplyr::mutate(real_world_share = count/sum(count, na.rm = T)) %>%
dplyr::rename(real_world_count = count)
#create summary stats for gender from training data
summary_td_gender <- synth_df %>%
dplyr::group_by(persoon_geslacht_vrouw) %>% #group by gender
dplyr::summarise(td_count = n()) %>% #count number of observations by gender
dplyr::rename(group_english = persoon_geslacht_vrouw) %>% #rename gender variable
dplyr::mutate(characteristic_english = 'gender', #set up variables to match the demographics_formatted df
group_english = ifelse(group_english == 1, 'woman', 'man'),
td_share = td_count/sum(td_count, na.rm = T))
#create summary stats for age from training data
summary_td_age <- synth_df %>%
#set up grouped age variable
dplyr::mutate(age_groups = case_when(persoon_leeftijd_bij_onderzoek < 27 ~ 'below_27',
persoon_leeftijd_bij_onderzoek >= 27 & persoon_leeftijd_bij_onderzoek < 45 ~ '27-45',
persoon_leeftijd_bij_onderzoek >= 45 ~ '45_above',
.default = NA)) %>%
dplyr::group_by(age_groups) %>% #group by age groups
dplyr::summarise(td_count = n()) %>% #count number of observations by age group
dplyr::rename(group_english = age_groups) %>% #rename age group variable
dplyr::mutate(characteristic_english = 'age', #set up variables to match the demographics_formatted df
td_share = td_count/sum(td_count, na.rm = T))
# TO EXPLORE: we could do the same for family status breakdowns but the variables in the training data aren't perfect matches for the
# family status classifications in the 'demographics'. You could explore whether the training data is representative using variables related to
# parenthood and relationship status. Also, check out the codebook at (look at 'data/02_feature_information/feature_handbook.xlsx').
#combine age and gender summary stats dataframes
summary_stats_td <- dplyr::bind_rows(summary_td_gender, summary_td_age)
#merge training data summary stats with realworld
demographics_formatted <- demographics_formatted %>%
dplyr::left_join(summary_stats_td, by = c('characteristic_english', 'group_english'))
#format data for plotting
demographics_long <- demographics_formatted %>%
dplyr::filter(!is.na(td_share)) %>%
tidyr::pivot_longer(cols = dplyr::ends_with('share'), names_to = 'data_source', values_to = 'share')%>%
dplyr::mutate(data_source = ifelse(data_source == 'td_share', 'training data', 'real world'))
#plot demographic breakdowns
ggplot2::ggplot(demographics_long, aes(x = group_english, y = share, fill = data_source))+
geom_bar(stat = 'identity', position = 'dodge') +
facet_wrap(.~characteristic_english, scales = 'free_x')+
labs(x = '', fill = 'Data Source',
title = 'Comparison between training data and real world demographic breakdowns')
#TO EXPLORE: Would you say these differences are sufficient that the training data should be considered
#unrepresentative? Are we sure that we are comparing apples to apples here? Have a look at this:
summary(synth_df$persoon_leeftijd_bij_onderzoek)
#Does this change your mind?
###Statistical Parity###
#predict synth data
risk_scores <- predict.train(final_model, newdata = synth_df, type = 'prob')
synth_df$risk <- risk_scores$Ja
#Let's make up a risk score threshold
threshold <- 0.7
synth_df <- synth_df %>%
mutate(high_risk = ifelse(risk > threshold, 1, 0))
#color coded overlapping density plot of risk scores by gender
ggplot(synth_df, aes(x = risk, colour = as.factor(persoon_geslacht_vrouw), fill = as.factor(persoon_geslacht_vrouw))) +
geom_density(alpha = 0.2)+
labs(x = 'Risk Score', y = 'Risk Score Density',
labs = 'Gender', title = 'Statistical Parity: Risk Score Distribution by Gender')
#Let's calculate some summary stats for the risk scores by gender
statistical_parity_summary_gender <- synth_df %>%
dplyr::group_by(persoon_geslacht_vrouw) %>%
dplyr::summarise(mean_risk = mean(risk, na.rm = T),
median_risk = median(risk, na.rm = T),
share_high_risk = mean(high_risk, na.rm = T))
print(statistical_parity_summary_gender)
###Conditional statistical parity###
#predict synth data
risk_scores <- predict.train(final_model, newdata = synth_df_gender, type = 'prob')
###Conditional statistical parity###
#predict synth data
risk_scores <- predict.train(final_model, newdata = synth_df_gender, type = 'prob')
synth_df_gender$risk <- risk_scores$Ja
#Let's make up a risk score threshold
synth_df_gender <- synth_df_gender %>%
mutate(high_risk = ifelse(risk > threshold, 1, 0))
#color coded overlapping density plot of risk scores by gender
ggplot(synth_df_gender, aes(x = risk, colour = as.factor(persoon_geslacht_vrouw), fill = as.factor(persoon_geslacht_vrouw))) +
geom_density(alpha = 0.2)+
labs(x = 'Risk Score', y = 'Risk Score Density',
labs = 'Gender', title = 'Conditional Statistical Parity: Risk Score Distribution by Gender')
#Let's calculate some summary stats for the risk scores by gender
statistical_parity_summary_gender <- synth_df_gender %>%
dplyr::group_by(persoon_geslacht_vrouw) %>%
dplyr::summarise(mean_risk = mean(risk, na.rm = T),
median_risk = median(risk, na.rm = T),
share_high_risk = mean(high_risk, na.rm = T))
print(statistical_parity_summary_gender)
#We didn't get access to the true outcome variable, i.e., whether a person has actually committed fraud or not. To illustrate other fairness definitions,
#which require true outcomes, we will make it up for illustrative purposes.
set.seed(9999) #setting a seed for reproducibility
synth_df$outcome <- NA
for(i in 1:nrow(synth_df)){
row <- synth_df[i,]
if(row$persoon_geslacht_vrouw == 1 & row$high_risk == 1){
synth_df[i,]$outcome <- rbinom(n=1, size=1, prob=0.6) #We set high-risk women's probability to 60%
} else if(row$persoon_geslacht_vrouw == 0 & row$high_risk == 1){
synth_df[i,]$outcome <- rbinom(n=1, size=1, prob=0.8) #We set high-risk men's probability to 80%
} else if(row$persoon_geslacht_vrouw == 1 & row$high_risk == 0){
synth_df[i,]$outcome <- rbinom(n=1, size=1, prob=0.3) #We set low-risk women's probability to 30%
} else {
synth_df[i,]$outcome <- rbinom(n=1, size=1, prob=0.5) #We set low-risk men's probability to 40%
}
}
#Make confusion matrix for overall result
cm <- table(synth_df$outcome, synth_df$high_risk, dnn = c('outcome', 'prediction'))
print(cm)
#Restrict dataset to men
synth_men <- synth_df %>%
dplyr::filter(persoon_geslacht_vrouw == 0)
#Restrict dataset to women
synth_women <- synth_df %>%
dplyr::filter(persoon_geslacht_vrouw == 1)
#Make confusion matrix for men
cm_men <- table(synth_men$outcome, synth_men$high_risk, dnn = c('outcome', 'prediction'))
print(cm_men)
#Make confusion matrix for women
cm_women <- table(synth_women$outcome, synth_women$high_risk, dnn = c('outcome', 'prediction'))
print(cm_women)
#Calculate key performance indicators using confusion matrix
calc_metrics <- function(cur_cm, category){
tp <- cur_cm[2,2]
fp <- cur_cm[1,2]
tn <- cur_cm[1,1]
fn <- cur_cm[2,1]
metrics <- data.frame(
cat = category,
overall_accuracy = ((tp + tn)/(tp+fp+tn+fn)), #How good is a model at distinguishing between between yes fraud/no fraud
precision = (tp/(tp+fp)), #Among the people flagged, what is the share of people who have actually commited fraud?
fp_error_balance = (fp/(fp+tn)) #Among the people who have not committed fraud, what is the share who were falsely flagged by the model
)
return(metrics)
}
#Calculate performance indicators overall, for men, and for women
metrics_overall <- calc_metrics(cm, 'overall')
metrics_men <- calc_metrics(cm_men, 'men')
metrics_women <- calc_metrics(cm_women, 'women')
metrics_combined <- bind_rows(metrics_overall, metrics_women, metrics_men)
print(metrics_combined)
#Calculate key performance indicators using confusion matrix
calc_metrics <- function(cur_cm, category){
tp <- cur_cm[2,2]
fp <- cur_cm[1,2]
tn <- cur_cm[1,1]
fn <- cur_cm[2,1]
metrics <- data.frame(
cat = category,
overall_accuracy = ((tp + tn)/(tp+fp+tn+fn)), #How good is a model at distinguishing between between yes fraud/no fraud
precision = (tp/(tp+fp)), #Among the people flagged, what is the share of people who have actually commited fraud?
fp_error = (fp/(fp+tn)) #Among the people who have not committed fraud, what is the share who were falsely flagged by the model
)
return(metrics)
}
#Calculate performance indicators overall, for men, and for women
metrics_overall <- calc_metrics(cm, 'overall')
metrics_men <- calc_metrics(cm_men, 'men')
metrics_women <- calc_metrics(cm_women, 'women')
metrics_combined <- bind_rows(metrics_overall, metrics_women, metrics_men)
print(metrics_combined)
setwd("/Users/justin-casimirbraun/GitHub/suspicion_machines_workshop")
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "/Users/justin-casimirbraun/GitHub/suspicion_machines_workshop")
if (!require("pacman")) install.packages("pacman")
pacman::p_load(dplyr, ggplot2, caret, tidyr, readxl, corrplot, gbm)
#This is synthetic data we build based on the real training data that was accidentally leaked to us.
# You can find our script to build this data here: https://github.com/Lighthouse-Reports/suspicion_machine
synth_df <- read.csv('data/01_raw/synth_data.csv')
#This is the same synthetic data as above but duplicated: in one copy, all people are set to be women, in the other, everybody is male
#You can also find the script we used to build the duplicates in our Github
synth_df_gender <- read.csv('data/01_raw/synth_data_gender.csv')
#This is the actual final model file from Rotterdam which we got through FOIA.
final_model <- readRDS('data/01_raw/20220929_finale_model.rds')$model[[1]]
#This is some basic demographic about the Rotterdam welfare beneficiary population we obtained through a press request.
demographics <- readxl::read_excel('data/01_raw/welfare_recepient_stats.xlsx', sheet = 'demographics')
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "/Users/justin-casimirbraun/GitHub/suspicion_machines_workshop")
if (!require("pacman")) install.packages("pacman")
pacman::p_load(dplyr, ggplot2, caret, tidyr, readxl, corrplot, gbm)
#This is synthetic data we build based on the real training data that was accidentally leaked to us.
# You can find our script to build this data here: https://github.com/Lighthouse-Reports/suspicion_machine
synth_df <- read.csv('data/01_raw/synth_data.csv')
#This is the same synthetic data as above but duplicated: in one copy, all people are set to be women, in the other, everybody is male
#You can also find the script we used to build the duplicates in our Github
synth_df_gender <- read.csv('data/01_raw/synth_data_gender.csv')
#This is the actual final model file from Rotterdam which we got through FOIA.
final_model <- readRDS('data/01_raw/20220929_finale_model.rds')$model[[1]]
#This is some basic demographic about the Rotterdam welfare beneficiary population we obtained through a press request.
demographics <- readxl::read_excel('data/01_raw/welfare_recepient_stats.xlsx', sheet = 'demographics')
print(demographics)
#format demographic data so it can be compared easily with the training data
demographics_formatted <- demographics %>%
dplyr::select(characteristic_english, group_english, count) %>%
dplyr::group_by(characteristic_english) %>%
dplyr::mutate(real_world_share = count/sum(count, na.rm = T)) %>%
dplyr::rename(real_world_count = count)
#create summary stats for gender from training data
summary_td_gender <- synth_df %>%
dplyr::group_by(persoon_geslacht_vrouw) %>% #group by gender
dplyr::summarise(td_count = n()) %>% #count number of observations by gender
dplyr::rename(group_english = persoon_geslacht_vrouw) %>% #rename gender variable
dplyr::mutate(characteristic_english = 'gender', #set up variables to match the demographics_formatted df
group_english = ifelse(group_english == 1, 'woman', 'man'),
td_share = td_count/sum(td_count, na.rm = T))
#create summary stats for age from training data
summary_td_age <- synth_df %>%
#set up grouped age variable
dplyr::mutate(age_groups = case_when(persoon_leeftijd_bij_onderzoek < 27 ~ 'below_27',
persoon_leeftijd_bij_onderzoek >= 27 & persoon_leeftijd_bij_onderzoek < 45 ~ '27-45',
persoon_leeftijd_bij_onderzoek >= 45 ~ '45_above',
.default = NA)) %>%
dplyr::group_by(age_groups) %>% #group by age groups
dplyr::summarise(td_count = n()) %>% #count number of observations by age group
dplyr::rename(group_english = age_groups) %>% #rename age group variable
dplyr::mutate(characteristic_english = 'age', #set up variables to match the demographics_formatted df
td_share = td_count/sum(td_count, na.rm = T))
#combine age and gender summary stats dataframes
summary_stats_td <- dplyr::bind_rows(summary_td_gender, summary_td_age)
#merge training data summary stats with realworld
demographics_formatted <- demographics_formatted %>%
dplyr::left_join(summary_stats_td, by = c('characteristic_english', 'group_english'))
#format data for plotting
demographics_long <- demographics_formatted %>%
dplyr::filter(!is.na(td_share)) %>%
tidyr::pivot_longer(cols = dplyr::ends_with('share'), names_to = 'data_source', values_to = 'share')%>%
dplyr::mutate(data_source = ifelse(data_source == 'td_share', 'training data', 'real world'))
#plot demographic breakdowns
ggplot2::ggplot(demographics_long, aes(x = group_english, y = share, fill = data_source))+
geom_bar(stat = 'identity', position = 'dodge') +
facet_wrap(.~characteristic_english, scales = 'free_x')+
labs(x = '', fill = 'Data Source',
title = 'Comparison between training data and real world demographic breakdowns')
neighborhood_variables <- names(synth_df)[grepl('adres_recentste_wijk', names(synth_df))]
demographic_variables <- c('persoon_geslacht_vrouw', 'persoon_leeftijd_bij_onderzoek', 'relatie_kind_huidige_aantal', 'persoonlijke_eigenschappen_spreektaal_anders')
#restrict training data to only contain demographic and neighborhood variables
synth_df_restricted <- synth_df %>%
dplyr::select(all_of(c(neighborhood_variables, demographic_variables)))
#compute correlation matrix for selected variables
corr_matrix <- cor(synth_df_restricted) %>%
as.data.frame() %>%
dplyr::select(all_of(neighborhood_variables)) %>% #keep only neighborhood variables as columns
dplyr::filter(row.names(.) %in% demographic_variables) %>% #keep only demographic variables as rows
as.matrix()
corrplot::corrplot(corr_matrix, method = 'color')
#TO EXPLORE: What else can we learn from a correlation analysis like this? It turns out that Rotterdam's model uses a bunch of subjective case worker assessments of beneficiaries to predict fraud. Are any of these characteristics associated with demographics? What would it mean for the model if they are? Many of these variables start with 'competentie_'!
###Statistical Parity###
#predict synth data
risk_scores <- predict.train(final_model, newdata = synth_df, type = 'prob')
synth_df$risk <- risk_scores$Ja
#Let's make up a risk score threshold
threshold <- 0.7
synth_df <- synth_df %>%
mutate(high_risk = ifelse(risk > threshold, 1, 0))
#color coded overlapping density plot of risk scores by gender
ggplot(synth_df, aes(x = risk, colour = as.factor(persoon_geslacht_vrouw), fill = as.factor(persoon_geslacht_vrouw))) +
geom_density(alpha = 0.2)+
labs(x = 'Risk Score', y = 'Risk Score Density',
labs = 'Gender', title = 'Statistical Parity: Risk Score Distribution by Gender')
#Let's calculate some summary stats for the risk scores by gender
statistical_parity_summary_gender <- synth_df %>%
dplyr::group_by(persoon_geslacht_vrouw) %>%
dplyr::summarise(mean_risk = mean(risk, na.rm = T),
median_risk = median(risk, na.rm = T),
share_high_risk = mean(high_risk, na.rm = T))
print(statistical_parity_summary_gender)
###Conditional statistical parity###
#predict synth data
risk_scores <- predict.train(final_model, newdata = synth_df_gender, type = 'prob')
synth_df_gender$risk <- risk_scores$Ja
#Let's make up a risk score threshold
synth_df_gender <- synth_df_gender %>%
mutate(high_risk = ifelse(risk > threshold, 1, 0))
#color coded overlapping density plot of risk scores by gender
ggplot(synth_df_gender, aes(x = risk, colour = as.factor(persoon_geslacht_vrouw), fill = as.factor(persoon_geslacht_vrouw))) +
geom_density(alpha = 0.2)+
labs(x = 'Risk Score', y = 'Risk Score Density',
labs = 'Gender', title = 'Conditional Statistical Parity: Risk Score Distribution by Gender')
#Let's calculate some summary stats for the risk scores by gender
statistical_parity_summary_gender <- synth_df_gender %>%
dplyr::group_by(persoon_geslacht_vrouw) %>%
dplyr::summarise(mean_risk = mean(risk, na.rm = T),
median_risk = median(risk, na.rm = T),
share_high_risk = mean(high_risk, na.rm = T))
print(statistical_parity_summary_gender)
#We didn't get access to the true outcome variable, i.e., whether a person has actually committed fraud or not. To illustrate other fairness definitions,
#which require true outcomes, we will make it up for illustrative purposes.
set.seed(9999) #setting a seed for reproducibility
synth_df$outcome <- NA
for(i in 1:nrow(synth_df)){
row <- synth_df[i,]
if(row$persoon_geslacht_vrouw == 1 & row$high_risk == 1){
synth_df[i,]$outcome <- rbinom(n=1, size=1, prob=0.6) #We set high-risk women's probability to 60%
} else if(row$persoon_geslacht_vrouw == 0 & row$high_risk == 1){
synth_df[i,]$outcome <- rbinom(n=1, size=1, prob=0.8) #We set high-risk men's probability to 80%
} else if(row$persoon_geslacht_vrouw == 1 & row$high_risk == 0){
synth_df[i,]$outcome <- rbinom(n=1, size=1, prob=0.3) #We set low-risk women's probability to 30%
} else {
synth_df[i,]$outcome <- rbinom(n=1, size=1, prob=0.5) #We set low-risk men's probability to 40%
}
}
#Make confusion matrix for overall result
cm <- table(synth_df$outcome, synth_df$high_risk, dnn = c('outcome', 'prediction'))
print(cm)
#Restrict dataset to men
synth_men <- synth_df %>%
dplyr::filter(persoon_geslacht_vrouw == 0)
#Restrict dataset to women
synth_women <- synth_df %>%
dplyr::filter(persoon_geslacht_vrouw == 1)
#Make confusion matrix for men
cm_men <- table(synth_men$outcome, synth_men$high_risk, dnn = c('outcome', 'prediction'))
print(cm_men)
#Make confusion matrix for women
cm_women <- table(synth_women$outcome, synth_women$high_risk, dnn = c('outcome', 'prediction'))
print(cm_women)
#Calculate key performance indicators using confusion matrix
calc_metrics <- function(cur_cm, category){
tp <- cur_cm[2,2]
fp <- cur_cm[1,2]
tn <- cur_cm[1,1]
fn <- cur_cm[2,1]
metrics <- data.frame(
cat = category,
overall_accuracy = ((tp + tn)/(tp+fp+tn+fn)), #How good is a model at distinguishing between between yes fraud/no fraud
precision = (tp/(tp+fp)), #Among the people flagged, what is the share of people who have actually commited fraud?
fp_error = (fp/(fp+tn)) #Among the people who have not committed fraud, what is the share who were falsely flagged by the model
)
return(metrics)
}
#Calculate performance indicators overall, for men, and for women
metrics_overall <- calc_metrics(cm, 'overall')
metrics_men <- calc_metrics(cm_men, 'men')
metrics_women <- calc_metrics(cm_women, 'women')
metrics_combined <- bind_rows(metrics_overall, metrics_women, metrics_men)
print(metrics_combined)
#TO EXPLORE: Can you think of other fairness definitions based on these confusion matrices? What other variables would you test this for?
# If you want to take a deep dive, we highly recommend this video: https://www.youtube.com/watch?v=jIXIuYdnyyk&t=6s and this paper is also great: https://fairware.cs.umass.edu/papers/Verma.pdf
print(cm)
print(metrics_combined)
#color coded overlapping density plot of risk scores by gender
ggplot(synth_df_gender, aes(x = risk, colour = as.factor(persoon_geslacht_vrouw), fill = as.factor(persoon_geslacht_vrouw))) +
geom_density(alpha = 0.2)+
labs(x = 'Risk Score', y = 'Risk Score Density',
labs = 'Gender', title = 'Conditional Statistical Parity: Risk Score Distribution by Gender')
